---
jupyter:
  jupytext:
    notebook_metadata_filter: all,-language_info
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
  kernelspec:
    display_name: R
    language: R
    name: ir
---

# Dataset QC Example 1
Repetitive, boring, and/or error-prone tasks should be scripted if possible; don't click if you can script!

Scripting can reduce how many errors occur and how quickly they're found (and corrected). For example, if a data file has a typo in the name a script will fail to find it while a person may click the file without noticing the typo. Scripts can also make it faster and easier to rerun an analysis or conversion if needed, such as to change a parameter.

When possible, have scripts read and write files directly from the intended permanent storage locations. For example, we store some files in [box](box.com). These files can be transferred by clicking options in the box web GUI, but this is slow it is easy to accidentally select the wrong file. Instead, we use [boxr](https://github.com/r-box/boxr) functions to retrieve and upload files from box. Box integration examples are not included here, but see [this DMCC example](https://github.com/ccplabwustl/dualmechanisms/blob/master/preparationsAndConversions/eprime/TEMPLATE_convertEprime.R). 

## Tutorial: converting eprime files to csv. 
### Background
- [Eprime](https://pstnet.com/products/e-prime/) saves its files in a proprietary format and non-human-readable plain text. We convert these to csv as quickly as possible after data collection. (Something I suggest doing for all non-standard file formats, not just eprime; store data in formats like nifti and text whenever possible for long-term accessibility.)
- This task is a prime target for scripting: the conversion must be done often and exactly, and accuracy can be tested algorithmically (e.g., by counting trial types).
- The tutorial eprime files are from a heartbeat-counting task like Pollatos, Traut-Mattausch, and Schandry ([2009](https://doi.org/10.1002/da.20504)). The task starts with a five-minute baseline period, followed by three trials during which the participant is asked to count their heart beats. After each trial participants verbally report how many beats they counted and their confidence in the count. The same trial order is used for all participants: the first is 25 seconds, second 35 seconds, and third 45 seconds.  
- For **Dataset QC** we will verify that the three trials, initial baseline, and final rest periods are present, and in the expected order and durations.

```{r}

# setwd("d:/maile/svnFiles/plein/conferences/ISMRM2022/onlineExample1"); # for Jo's local testing

 test <- readLines("interoception_demoSub1.txt", warn=FALSE);
 print(length(test));  # should be 315
 
```

This script uses the [eMergeR](https://github.com/AWKruijt/eMergeR) R library's functions for parsing information out of the eprime text recovery file. I generally suggest starting each script by loading any needed libraries, clearing R's memory, setting options, and defining needed variables. This first code block loads eMergeR, clears R's workspace, and sets the input and output paths. 

```{r}
library(eMergeR);   # for edatR(), as.data.frame.edat(). https://github.com/AWKruijt/eMergeR
rm(list=ls());   # clear R's workspace (I usually do this; not sure about in a notebook)
options(warnPartialMatchDollar=TRUE);   # safety option; adds warnings for partial matches

# I strongly recommend explicitly setting complete paths at the top of a script rather than using setwd()
# or similar, but this notebook operation requires relative paths, so the variables are empty placeholders.
in.path <- "example1files/";    # directory with the input files, usually something like in.path <- "d:/temp/input/";   
out.path <- "";   # directory in which the converted files should be written out.path <- "d:/temp/output/";   


```

Next is a function to carry out the conversion. This type of function could be stored in a separate file which is then `source`d at the top of the file with the other startup code. Note that the function includes several checks that the expected values are present. This is valuable for catching errors or changes as quickly as possible, such as if the task presentation script was accidentally edited partway through the study.

```{r}

do.convert <- function(sub.id, do.overwrite=FALSE) {  # sub.id <- "demoSub1"; do.overwrite <- FALSE;
  return.str <- paste("starting", sub.id, "......");  # start a message for the function to return
  found.error <- FALSE;  # error-found flag to avoid stop() or multiple return() statements
  
  # make the output directory if it doesn't already exist 
  # if (!dir.exists(out.path)) { dir.create(out.path); }
  
  # check if the input file exists
  fname <- paste0("interoception_", sub.id, ".txt");   # build expected input filename
  if (!file.exists(paste0(in.path, fname))) {    # check if it exists and print error message if not.
    return.str <- c(return.str, paste0("ERROR: missing input file ", in.path, fname, "!")); 
    found.error <- TRUE;  # change flag
  } 
  
  # check if output file already exists, and stop if so and do.overwrite is FALSE
  out.fname <- paste0("interoception-", sub.id, "-converted.csv");  # name of the output file to be made
  if (file.exists(paste0(out.path, out.fname)) & do.overwrite == FALSE & !found.error) { 
    return.str <- c(return.str, paste0("found ", out.path, out.fname));
    return.str <- c(return.str, "and do.overwrite=FALSE, so conversion stopped! Move file and run do.convert again,");
    return.str <- c(return.str, "or run with do.overwrite=TRUE to replace the file.");
    found.error <- TRUE;  # change flag
  }
  
  
  if (found.error == FALSE) {   # file exists, so read it and convert.
    e.in <- edatR(paste0(in.path, fname));     # eMergeR function for reading text recovery files
    e.tbl <- as.data.frame.edat(e.in, simplify=TRUE);   # initial conversion
    
    # check that some fields are present and have the expected values
    if (!identical(e.tbl$Procedure, c("baselineProc", "rest", "trigger", "rest", "trigger", "rest", "trigger", "rest"))) { 
      return.str <- c(return.str, "ERROR: mismatch in $Procedure!"); 
      found.error <- TRUE;  # change flag
    }
    if (!is.na(e.tbl$black.OnsetTime[1]) | !is.na(e.tbl$black.OffsetTime[1])) { 
      return.str <- c(return.str, "ERROR: have baseline onsets or offsets??"); 
      found.error <- TRUE;  # change flag
    }
    
    # check that the baseline period is present and of the expected duration
    tmp.vec <- e.in$trial_info$`1`;    # how the baseline5min onset & offset times are in the eprime file
    # times in msec, so divide by 1000 for seconds, and 60 for minutes
    if ((as.numeric(tmp.vec["baseline5min.OffsetTime"]) - as.numeric(tmp.vec["baseline5min.OnsetTime"]))/60000 != 5) { 
      return.str <- c(return.str, "ERROR: the baseline was not 5 minutes"); 
      found.error <- TRUE;  # change flag
    } 
  }
    
  if (found.error == FALSE) {   # duration was correct, so store values in correct output table spots and write
    e.tbl$black.OnsetTime[1]  <- tmp.vec["baseline5min.OnsetTime"];
    e.tbl$black.OffsetTime[1] <- tmp.vec["baseline5min.OffsetTime"];
    
    # now have all the information, so write as a csv
    write.csv(e.tbl, paste0(out.path, out.fname), row.names=FALSE);
    
    if (file.exists(paste0(out.path, out.fname))) {   # confirm file present and print a success message
      return.str <- c(return.str, paste("success! wrote", out.fname, "to disk."));
    } else { 
      return.str <- c(return.str, paste("ERROR: didn't write", out.fname, "to disk!!!!")); 
    }
  }
  
  print(return.str);
  return();
}

```

Then we can call the function to convert each participant's data. Notice the success and error messages that are printed.

```{r}

do.convert("demoSub1");  # default is do.overwrite=FALSE
do.convert("demoSub1", do.overwrite=TRUE);
do.convert("demoSub2");   # input filename is incorrect

# or with a loop. Note that one subject ID has a typo and demoSub4 has a timing error.
sub.ids <- c("demoSub1", "demoSub3", "damoSub3", "demoSub4");
for (sid in 1:length(sub.ids)) { do.convert(sub.ids[sid]); }

```
